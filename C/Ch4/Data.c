/*
	작성일 : 2025.02.20
	작성자 : 손용민
	주제 : 데이터 표현 방식
*/

/*
	2가지의 타입 : 정수, 실수
	int, char, short, long, longlong - 정수
	float, double, decimal - 실수

	(사람 - 사람) (컴퓨터 - 사람) int 어떻게 이해를 할까?
	int 변수이름; 변수이름 녀석이 정수형태의 값을 받을 수 있다. + 데이터 저장 크기를 지정

	정수를 표현하는 방법
	- 표현하는 키워드가 많음 why?
	- 최선의 메모리를 사용하기 위해서 -> 옛날에는 하드 자체의 크기가 작았기 때문임
	- 컴퓨터 정보를 읽는 최소 단위 : 바이트 = 8비트
	- bit (0,1)

	char(1), short(2), int(4)
	0000 0000, (0000 0000)x2 ... 라는 뜻

	뺄셈 : A - B -> A + (-B)
	정수 : 음수를 표현하는 방법
	MSB : Most Signmant Bit : 데이터 표현방식에서 가장 왼쪽 끝에 있는 비트에 할당함
	0 : 양수, 1 : 음수

	2의 보수법
	- 양수를 비트로 표현. 모든 비트를 반전 + 1;
		0000 0101
		1111 1010
		1111 1111
				1
		0000 0000

	5양수 0000 0101
	5음수 1000 0101
				
	메모리 측면.
	unsigned int
*/

/*
	실수를 표현하는 방식
	2바이트	0000 0000	0000 0000
	
	반반 나눠서(고정소수점 방식) 사용하기에는 실수를 표현할 수 있는 범위가 너무 작음 따라서 아래와 같은 방식이 나옴.

	부동소수점 방식 : float
	정규화된식^(지수) 를 이용해서 표현
	어떤 수를 제곱, 1;
	33^0 = 1;

	수를 0< <10 사이의 수로 표현
	0.2334

	부동소수점의 오차가 발생한다.
	1 과 1.0은 컴퓨터에서 다르다.

*/

/*
	int attackpower = 10 + 1 * 0.3;

	리터럴 상수
	int, double
	1 * 0.3;
	int 정의 => 0
	double 정의 => 0.3
	둘 중 뭘 사용할까 ? 정답은 없음
	이유 -> 데이터 손실을 최소화 하기 위해 사용함

	데이터 형 -> 스스로 형태를 바꾸고 있다.
	형 변환
	- 자동 : 묵시적 변환
	- 수동 : 명시적 변환

	프로그래머란? 현재의 도구를 가지고 풀 수 없는 문제를 풀기 위해 존재함
*/
#include <stdio.h>

int main() {
	int attackpower = 10 + 1 * 0.3;
	double attackpower2 = 10 + 1 * 0.3;

	printf("값 : %d\n", attackpower); // 10
	printf("값 : %lf\n", attackpower2); // 10.3

	printf("\n\n");
	printf("정수의 표현 방식 실습\n");
	
	char num1 = 129;	// 0000 0000
						// 0111 1111	127	
						// 1000 0001
						
	int num2 = 129;		// ( ) ( ) ( ) 1000 0001 int에서는 2^8승 자리가 부호 비트가 아니니 표현이 됨
	char num3 = num2;	// 1111 1111 인데 2^8승자리가 부호비트니 -127이 뜸

	printf("num1 = %d\n", num1);
	printf("num1 = %d\n", num2);
	printf("num1 = %d\n", num3);

	printf("\n\n");
	printf("실수의 표현 방식\n");

	float num4 = 0.1;
	
	for (int i = 0; i < 1000; i++) {
		num4 += 0.1;
	}
	printf("%f", num4); // 100.09234.. 로 나옴 즉, 1과 1.0은 다르다는 것을 알 수 있다.	
}